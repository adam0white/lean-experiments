msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-05\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.LogicForEngineers.L09_Iff
msgid "The XNOR Gate"
msgstr ""

#. ยง0: `my_map`
#. ยง1: `(my_map f L).length = L.length`
#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "# Ticket-1042: Buffer Overflow Check\n"
"\n"
"**Status:** OPEN\n"
"**Priority:** P0 (Security)\n"
"\n"
"**Description:**\n"
"The security team is worried about buffer overflows.\n"
"We need to verify that ยง0 allocates exactly the same amount of memory as the input list.\n"
"If the length changes, we might write out of bounds.\n"
"\n"
"**Acceptance Criteria:**\n"
"Prove that ยง1."
msgstr ""

#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Prove that reversing a list does not change its length."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `L1`
#. ยง1: `induction L1`
#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "We want to prove this for any list ยง0.\n"
"Type ยง1."
msgstr ""

#. ยง0: `intro h`
#: Game.Levels.LogicForEngineers.L02_Implication
msgid "Use ยง0 to assume P is true. This moves P from the goal to your hypotheses."
msgstr ""

#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "One direction of De Morgan's first law."
msgstr ""

#. ยง0: `P โง (Q โจ R)`
#. ยง1: `(P โง Q) โจ (P โง R)`
#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "Great job! You've verified the query optimizer rule!\n"
"\n"
"**Performance Impact:**\n"
"- Original: ยง0 - Filter *after* Join (Slow)\n"
"- Optimized: ยง1 - Filter *before* Join (Fast)\n"
"\n"
"You just saved the dashboard from timing out. The intern is impressed."
msgstr ""

#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "If P and Q are both true, then P โง Q is true."
msgstr ""

#. ยง0: `h : ยฌP โจ ยฌQ`
#. ยง1: `hpq : P โง Q`
#. ยง2: `cases h`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "You have ยง0 and ยง1. Use ยง2 to handle both possibilities."
msgstr ""

#. ยง0: `Q`
#. ยง1: `h : P โง Q`
#. ยง2: `exact h.right`
#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "You need to prove ยง0. You have ยง1.\n"
"Use ยง2 to extract Q from the AND."
msgstr ""

#. ยง0: `length [head]`
#. ยง1: `simp`
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Now simplify the arithmetic. ยง0 is 1.\n"
"Type ยง1."
msgstr ""

#. ยง0: `hp : P`
#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "Now prove the first part. You have ยง0 in your hypotheses."
msgstr ""

#. ยง0: `intro h`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "First introduce the hypothesis with ยง0."
msgstr ""

#. ยง0: `intro h`
#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "Start with ยง0 to assume the unoptimized query structure."
msgstr ""

#. ยง0: `left`
#. ยง1: `left`
#. ยง2: `right`
#: Game.Levels.LogicForEngineers.L05_OrIntro
msgid "You've learned OR introduction from the left!\n"
"\n"
"The ยง0 tactic says 'I choose to prove the left side of the OR'.\n"
"\n"
"**Note:** Once you commit to ยง1 or ยง2, you only need to prove that one side.\n"
"This is different from AND where you must prove both!"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `intro h`
#: Game.Levels.LogicForEngineers.L09_Iff
msgid "First, assume ยง0 is true with ยง1."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `Q โ P`
#. ยง1: `h : P โ Q`
#. ยง2: `h.mpr`
#. ยง3: `Q โ P`
#. ยง4: `exact h.mpr`
#: Game.Levels.LogicForEngineers.L09_Iff
msgid "You need ยง0. You have ยง1.\n"
"Use ยง2 to get the ยง3 direction, then ยง4."
msgstr ""

#. ยง0: `hnp : ยฌP`
#. ยง1: `hpq : P โง Q`
#. ยง2: `hpq.left`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "You have ยง0 and ยง1.\n"
"Extract P from hpq with ยง2, then apply ยฌP to it."
msgstr ""

#. ยง0: `(my_map f tail).length + 1 = tail.length + 1`
#. ยง1: `(my_map f tail).length = tail.length`
#. ยง2: `ih`
#. ยง3: `rw [ih]`
#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "Now the goal looks like ยง0.\n"
"We know ยง1 from ยง2.\n"
"Use ยง3 to replace the left side with the right side."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `P โง Q`
#. ยง2: `P`
#. ยง3: `Q`
#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "Use ยง0 to split the goal ยง1 into two separate goals: ยง2 and ยง3."
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `ยฌP`
#. ยง2: `P โ False`
#. ยง3: `ยฌP`
#. ยง4: `intro h`
#. ยง5: `False`
#. ยง6: `h : P`
#. ยง7: `hn : ยฌP`
#. ยง8: `hn h`
#. ยง9: `False`
#. ยง10: `False.elim`
#. ยง11: `False`
#: Game.Levels.LogicForEngineers.L07_NotGate
msgid "# NOT: Negation\n"
"\n"
"A **NOT gate** (inverter) flips the signal: HIGH becomes LOW, LOW becomes HIGH.\n"
"\n"
"In logic, ยง0 (read 'not P') means P is false.\n"
"\n"
"**Key insight:** In Lean, ยง1 is *defined* as ยง2.\n"
"This means: 'if P were true, we'd have a contradiction'.\n"
"\n"
"To prove ยง3:\n"
"1. Use ยง4 to assume P is true\n"
"2. Derive ยง5 from that assumption\n"
"\n"
"If you have both ยง6 and ยง7, you have a contradiction!\n"
"- ยง8 gives you ยง9 (applying ยฌP to P)\n"
"- ยง10 converts ยง11 into any proposition"
msgstr ""

#. ยง0: `my_map`
#. ยง1: `rfl`
#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "Base Case: The list is empty. ยง0 returns empty, and length is 0.\n"
"This should be true by definition. Type ยง1."
msgstr ""

#: Game.Levels.LogicForEngineers.L05_OrIntro
msgid "The OR Gate"
msgstr ""

#. ยง0: `L`
#. ยง1: `induction L`
#: Game.Levels.TheDataCenter.L01_MapId
msgid "We need to prove this for *any* list ยง0. This suggests induction.\n"
"Type ยง1."
msgstr ""

#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "AND is commutative: P โง Q implies Q โง P."
msgstr ""

#: Game.Levels.LogicForEngineers.L05_OrIntro
msgid "Now just prove P using your hypothesis."
msgstr ""

#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "Safe Mapping"
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `P โจ Q`
#. ยง2: `left`
#. ยง3: `P`
#. ยง4: `right`
#. ยง5: `Q`
#: Game.Levels.LogicForEngineers.L05_OrIntro
msgid "# OR: At Least One Must Be True\n"
"\n"
"An **OR gate** outputs HIGH when *at least one* input is HIGH.\n"
"\n"
"In logic, ยง0 (read 'P or Q') is true when at least one of P or Q is true.\n"
"\n"
"To prove ยง1, you only need to prove ONE side:\n"
"- Use ยง2 if you can prove ยง3\n"
"- Use ยง4 if you can prove ยง5\n"
"\n"
"You're essentially choosing which input to connect to HIGH."
msgstr ""

#. ยง0: `my_map`
#. ยง1: `id`
#. ยง2: `my_map id L`
#. ยง3: `L`
#. ยง4: `my_map id L = L`
#. ยง5: `L`
#: Game.Levels.TheDataCenter.L01_MapId
msgid "# Ticket-1041: Pipeline Integrity\n"
"\n"
"**Status:** OPEN\n"
"**Priority:** P1\n"
"\n"
"**Description:**\n"
"We are defining a ยง0 function to transform data streams.\n"
"Before we deploy, we need to guarantee that mapping the ยง1 (identity) function acts as a no-op.\n"
"If ยง2 changes the list ยง3, we have a major bug in our pipeline.\n"
"\n"
"**Acceptance Criteria:**\n"
"Prove that ยง4 for any list ยง5."
msgstr ""

#. ยง0: `trivial`
#: Game.Levels.LogicForEngineers.L01_TrueIsTrue
msgid "Excellent! You've completed your first proof.\n"
"\n"
"The ยง0 tactic works when the goal is obviously true.\n"
"In circuit terms, you just verified that a wire connected to VCC is indeed HIGH.\n"
"\n"
"Let's move on to something more interesting!"
msgstr ""

#. ยง0: `L1`
#. ยง1: `my_append [] L2`
#. ยง2: `L2`
#. ยง3: `[].length`
#. ยง4: `L2.length = 0 + L2.length`
#. ยง5: `simp [my_append]`
#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "Base Case: ยง0 is empty.\n"
"ยง1 is just ยง2.\n"
"And ยง3 is 0.\n"
"So we need to prove ยง4.\n"
"This is true by definition and basic arithmetic.\n"
"Type ยง5."
msgstr ""

#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Ticket-1045: Backup Integrity Check"
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `intro h`
#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "First, assume ยง0 is true using ยง1."
msgstr ""

#: Game.Levels.TheDataCenter.L04_MapComp
msgid "Ticket-1044: Optimization Pass Safety"
msgstr ""

#: Game.Levels.LogicForEngineers.L09_Iff
msgid "If and only if is symmetric."
msgstr ""

#. ยง0: `P โง (Q โจ R)`
#. ยง1: `Q`
#. ยง2: `R`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `R`
#. ยง6: `(P โง Q) โจ (P โง R)`
#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "# Query Optimization: The Distributive Law\n"
"\n"
"The intern wrote a query that is causing a massive slowdown in our analytics dashboard.\n"
"They are filtering a join like this: ยง0.\n"
"\n"
"This forces the database to join ยง1 and ยง2 first, creating a huge intermediate table, and *then* filter by ยง3.\n"
"\n"
"If we distribute the filter, we can filter ยง4 and ยง5 *before* joining:\n"
"ยง6\n"
"\n"
"This is a classic query optimization technique!\n"
"\n"
"Your task: Prove to the intern that this optimization is safe (logically equivalent)."
msgstr ""

#. ยง0: `(my_append tail L2).length + 1 = tail.length + 1 + L2.length`
#. ยง1: `tail_ih`
#. ยง2: `(my_append tail L2).length = tail.length + L2.length`
#. ยง3: `rw [tail_ih]`
#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "Now we have ยง0.\n"
"The Induction Hypothesis ยง1 says ยง2.\n"
"Use ยง3 to use this fact."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P โ Q`
#. ยง2: `P โ Q`
#. ยง3: `constructor`
#. ยง4: `P โ Q`
#. ยง5: `Q โ P`
#. ยง6: `h : P โ Q`
#. ยง7: `h.mp`
#. ยง8: `P โ Q`
#. ยง9: `h.mpr`
#. ยง10: `Q โ P`
#: Game.Levels.LogicForEngineers.L09_Iff
msgid "# Biconditional: If and Only If\n"
"\n"
"The **XNOR gate** (exclusive NOR) outputs HIGH when both inputs are the same.\n"
"In logic, this is the **biconditional** ยง0 (read 'P if and only if Q').\n"
"\n"
"ยง1 means:\n"
"- If P is true, then Q is true (P โ Q)\n"
"- If Q is true, then P is true (Q โ P)\n"
"\n"
"It's essentially two implications in both directions!\n"
"\n"
"To prove ยง2:\n"
"- Use ยง3 to split into two goals: ยง4 and ยง5\n"
"- Prove each direction separately\n"
"\n"
"To use ยง6:\n"
"- ยง7 (modus ponens): gives you ยง8\n"
"- ยง9 (modus ponens reverse): gives you ยง10"
msgstr ""

#. ยง0: `โ`
#. ยง1: `\\iff`
#. ยง2: `\\leftrightarrow`
#. ยง3: `constructor`
#. ยง4: `.mp`
#. ยง5: `.mpr`
#: Game.Levels.LogicForEngineers.L09_Iff
msgid "Wonderful! You've shown that biconditional is symmetric.\n"
"\n"
"**The ยง0 symbol:**\n"
"- Typed as ยง1 or ยง2\n"
"- ยง3 splits it into two implication goals\n"
"- ยง4 extracts the forward direction (P โ Q)\n"
"- ยง5 extracts the reverse direction (Q โ P)\n"
"\n"
"In circuits, XNOR is the 'equality detector' - it's HIGH when both inputs match!"
msgstr ""

#. ยง0: `f`
#. ยง1: `g`
#. ยง2: `g โ f`
#: Game.Levels.TheDataCenter.L04_MapComp
msgid "Prove that mapping ยง0 then ยง1 is the same as mapping ยง2."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P โ P`
#. ยง2: `P โ Q`
#. ยง3: `intro h`
#. ยง4: `P`
#. ยง5: `h`
#. ยง6: `Q`
#. ยง7: `exact h`
#: Game.Levels.LogicForEngineers.L02_Implication
msgid "# Implication: If...Then\n"
"\n"
"In circuits, a buffer gate passes the input signal through unchanged.\n"
"In logic, an **implication** ยง0 means 'if P is true, then Q is true'.\n"
"\n"
"The simplest implication is ยง1 - if the input is true, the output is true.\n"
"This is like a buffer: what goes in, comes out.\n"
"\n"
"To prove an implication ยง2:\n"
"1. Use ยง3 to assume ยง4 is true (calling this assumption ยง5)\n"
"2. Then prove ยง6 using that assumption\n"
"\n"
"When you have exactly what you need to prove, use ยง7 to finish."
msgstr ""

#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "**Restoration Verified!**\n"
"\n"
"The reverse operation is length-preserving.\n"
"No data records were lost during the restoration process.\n"
"The 'The Data Center' is now fully verified and operational!"
msgstr ""

#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "The AND Gate"
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `left`
#. ยง2: `constructor`
#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "In this case, we are in the left branch (Q). Build the optimized left side ยง0.\n"
"Use ยง1 then ยง2."
msgstr ""

#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "Ticket-1043: Merge Logic Verification"
msgstr ""

#: Game.Levels.TheDataCenter.L04_MapComp
msgid "**Optimization Verified!**\n"
"\n"
"The compiler can now safely fuse these loops.\n"
"You've saved the company millions of CPU cycles!"
msgstr ""

#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "Query Optimization"
msgstr ""

#. ยง0: `my_map id []`
#. ยง1: `[]`
#. ยง2: `rfl`
#: Game.Levels.TheDataCenter.L01_MapId
msgid "Base Case: ยง0.\n"
"By definition, this is ยง1.\n"
"This is true by definition (reflexivity).\n"
"Type ยง2."
msgstr ""

#: Game.Levels.LogicForEngineers.L07_NotGate
msgid "From P and ยฌP, we can prove anything."
msgstr ""

#. ยง0: `id head :: my_map id tail`
#. ยง1: `id head = head`
#. ยง2: `id`
#. ยง3: `my_map id tail = tail`
#. ยง4: `ih`
#. ยง5: `head :: tail = head :: tail`
#. ยง6: `ih`
#. ยง7: `rw [ih]`
#: Game.Levels.TheDataCenter.L01_MapId
msgid "Now we have ยง0.\n"
"We know ยง1 (by definition of ยง2) and ยง3 (by ยง4).\n"
"So the goal is ยง5.\n"
"Use the induction hypothesis ยง6 to rewrite the goal.\n"
"Type ยง7."
msgstr ""

#. ยง0: `trivial`
#. ยง1: `intro`
#. ยง2: `exact`
#. ยง3: `constructor`
#. ยง4: `.left`
#. ยง5: `.right`
#. ยง6: `left`
#. ยง7: `right`
#. ยง8: `cases`
#. ยง9: `ยฌP`
#. ยง10: `P โ False`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "Congratulations! You've proven part of De Morgan's Law!\n"
"\n"
"This is exactly how digital circuit designers think:\n"
"- A NAND gate (ยฌ(P โง Q)) outputs LOW only when both inputs are HIGH\n"
"- An OR of NOTs (ยฌP โจ ยฌQ) outputs HIGH when at least one input is LOW\n"
"- These are logically equivalent!\n"
"\n"
"**What you've learned:**\n"
"- ยง0 - prove something obviously true\n"
"- ยง1 - assume the hypothesis of an implication\n"
"- ยง2 - finish with an exact match\n"
"- ยง3 - split an AND goal into two goals\n"
"- ยง4, ยง5 - extract from an AND hypothesis\n"
"- ยง6, ยง7 - choose which side of OR to prove\n"
"- ยง8 - handle OR hypotheses by considering both cases\n"
"- Understanding ยง9 as ยง10"
msgstr ""

#: Game.Levels.LogicForEngineers.L01_TrueIsTrue
msgid "Prove that True is true."
msgstr ""

#. ยง0: `length (my_reverse tail) + length [head]`
#. ยง1: `tail_ih`
#. ยง2: `length (my_reverse tail)`
#. ยง3: `length tail`
#. ยง4: `rw [tail_ih]`
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Now we have ยง0.\n"
"Use the induction hypothesis ยง1 to replace ยง2 with ยง3.\n"
"Type ยง4."
msgstr ""

#. ยง0: `P`
#. ยง1: `exact h.left`
#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "You need to prove ยง0. Use ยง1 to extract P from the AND."
msgstr ""

#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "Case Analysis on OR"
msgstr ""

#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "**Integration Successful!**\n"
"\n"
"You've verified that our data merge operation is safe.\n"
"The total record count is preserved.\n"
"\n"
"You are becoming a master of structural induction!"
msgstr ""

#: Game.Levels.LogicForEngineers.L07_NotGate
msgid "The NOT Gate"
msgstr ""

#. ยง0: `my_map`
#. ยง1: `rfl`
#: Game.Levels.TheDataCenter.L04_MapComp
msgid "Base Case: Empty list.\n"
"ยง0 of empty is empty.\n"
"Type ยง1."
msgstr ""

#. ยง0: `L`
#. ยง1: `induction L`
#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "Just like in the previous level, we need to prove this for *any* list ยง0.\n"
"This is a job for induction!\n"
"Type ยง1."
msgstr ""

#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "OR is commutative: P โจ Q implies Q โจ P."
msgstr ""

#. ยง0: `h.left`
#. ยง1: `h.1`
#. ยง2: `h.right`
#. ยง3: `h.2`
#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "Excellent! You've proven that AND is commutative.\n"
"\n"
"**Extracting from AND:**\n"
"- ยง0 or ยง1 - get the first component\n"
"- ยง2 or ยง3 - get the second component\n"
"\n"
"In circuit terms, if an AND gate outputs 1, both inputs must be 1.\n"
"You can 'read' either input!"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `exact h.mp`
#: Game.Levels.LogicForEngineers.L09_Iff
msgid "You need ยง0. Use ยง1."
msgstr ""

#. ยง0: `L`
#. ยง1: `induction L`
#: Game.Levels.TheDataCenter.L04_MapComp
msgid "We need to prove this for any list ยง0.\n"
"Induction is your friend.\n"
"Type ยง1."
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `P โ False`
#. ยง2: `hnp : ยฌP`
#. ยง3: `hp : P`
#. ยง4: `hnp hp : False`
#. ยง5: `False`
#. ยง6: `ยฌ`
#. ยง7: `\\not`
#. ยง8: `\\neg`
#: Game.Levels.LogicForEngineers.L07_NotGate
msgid "This is the principle of **explosion** (ex falso quodlibet):\n"
"from a contradiction, you can prove anything!\n"
"\n"
"**Understanding ยฌP:**\n"
"- ยง0 is just shorthand for ยง1\n"
"- If you have ยง2 and ยง3, then ยง4\n"
"- From ยง5, any proposition follows\n"
"\n"
"**Notation:** ยง6 is typed as ยง7 or ยง8\n"
"\n"
"In circuits, if you somehow have a signal that's both HIGH and LOW,\n"
"something is very wrong - and anything could happen!"
msgstr ""

#: Game.Levels.LogicForEngineers
#: Game
msgid "Logic for Engineers"
msgstr ""

#. ยง0: `my_map`
#: Game.Levels.TheDataCenter.L01_MapId
msgid "**Identity Verified!**\n"
"\n"
"You've confirmed that ยง0 behaves correctly for the simplest case.\n"
"Now we can move on to the more complex safety check."
msgstr ""

#. ยง0: `hp : P`
#. ยง1: `hnp : ยฌP`
#. ยง2: `ยฌP`
#. ยง3: `P โ False`
#. ยง4: `hnp`
#. ยง5: `hp`
#. ยง6: `False`
#. ยง7: `exact False.elim (hnp hp)`
#: Game.Levels.LogicForEngineers.L07_NotGate
msgid "You have both ยง0 and ยง1.\n"
"Since ยง2 means ยง3, applying ยง4 to ยง5 gives ยง6.\n"
"Use ยง7 to derive any proposition from False!"
msgstr ""

#. ยง0: `simp [Nat.add_assoc, Nat.add_comm]`
#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "Now both sides are equal (by associativity and commutativity of addition).\n"
"Type ยง0."
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Base Case: Reversing an empty list gives empty.\n"
"Type ยง0."
msgstr ""

#. ยง0: `length (my_append ... ...)`
#. ยง1: `length`
#. ยง2: `my_append`
#. ยง3: `rw [append_length]`
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "We have ยง0.\n"
"We proved in Level 3 that ยง1 distributes over ยง2.\n"
"We can use that theorem!\n"
"Type ยง3."
msgstr ""

#. ยง0: `map g (map f L)`
#. ยง1: `map (g โ f) L`
#. ยง2: ```lean
#. def my_map (f : ฮฑ โ ฮฒ) (L : List ฮฑ) : List ฮฒ :=
#.   match L with
#.   | [] => []
#.   | (head :: tail) => f head :: my_map f tail
#. ```
#. ยง3: `my_map g (my_map f L) = my_map (g โ f) L`
#: Game.Levels.TheDataCenter.L04_MapComp
msgid "# Ticket-1044: Optimization Pass Safety\n"
"\n"
"**Status:** IN REVIEW\n"
"**Priority:** P2 (Performance)\n"
"\n"
"**Description:**\n"
"The compiler team wants to enable 'Map Fusion' optimization.\n"
"They claim that ยง0 is equivalent to ยง1.\n"
"We need to mathematically prove this optimization is safe before enabling it in production.\n"
"\n"
"**The Code:**\n"
"ยง2\n"
"\n"
"**Acceptance Criteria:**\n"
"Prove that ยง3."
msgstr ""

#. ยง0: `True`
#. ยง1: `โง`
#. ยง2: `โจ`
#. ยง3: `ยฌ`
#. ยง4: `โ`
#: Game.Levels.LogicForEngineers
msgid "# Welcome to Logic for Engineers!\n"
"\n"
"If you've worked with digital circuits, you already understand Boolean logic:\n"
"- **AND gates** output HIGH when both inputs are HIGH\n"
"- **OR gates** output HIGH when at least one input is HIGH\n"
"- **NOT gates** flip the signal\n"
"\n"
"In this world, you'll learn to *prove* logical statements using the same concepts.\n"
"Instead of building circuits, you'll build proofs!\n"
"\n"
"**What you'll learn:**\n"
"- Level 1: The ยง0 proposition (like VCC - always HIGH)\n"
"- Level 2: Implications (the buffer gate)\n"
"- Level 3-4: AND (ยง1) - introduction and elimination\n"
"- Level 5-6: OR (ยง2) - introduction and elimination\n"
"- Level 7: NOT (ยง3) - negation and contradiction\n"
"- Level 8: De Morgan's Laws (NAND and NOR equivalences)\n"
"- Level 9: Biconditional (ยง4) - the XNOR gate\n"
"- Level 10: Query Optimization - database efficiency\n"
"\n"
"Let's start with something simple and build up to proving real logic identities!"
msgstr ""

#. ยง0: `head :: tail`
#. ยง1: `simp [my_map, tail_ih]`
#: Game.Levels.TheDataCenter.L04_MapComp
msgid "Recursive Case: ยง0.\n"
"Simplify using definitions and the induction hypothesis.\n"
"Type ยง1."
msgstr ""

#. ยง0: `ยฌ(P โง Q)`
#. ยง1: `P โง Q โ False`
#. ยง2: `intro hpq`
#. ยง3: `P โง Q`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "Now you need to prove ยง0. Remember, this means ยง1.\n"
"Use ยง2 to assume ยง3 is true."
msgstr ""

#. ยง0: `intro h`
#. ยง1: `โ`
#. ยง2: `h`
#. ยง3: `exact h`
#. ยง4: `h`
#. ยง5: `intro`
#. ยง6: `exact`
#: Game.Levels.LogicForEngineers.L02_Implication
msgid "Perfect! You just proved the logical equivalent of a buffer gate.\n"
"\n"
"**Key tactics learned:**\n"
"- ยง0 - Assume the left side of ยง1 is true, calling it ยง2\n"
"- ยง3 - Use hypothesis ยง4 when it matches the goal exactly\n"
"\n"
"The pattern ยง5 then ยง6 is fundamental - you'll use it constantly!"
msgstr ""

#. ยง0: `hq : Q`
#. ยง1: `Q โจ P`
#. ยง2: `left`
#. ยง3: `exact hq`
#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "In this case, Q is true (you have ยง0). You need ยง1.\n"
"Since you have Q, use ยง2 then ยง3."
msgstr ""

#. ยง0: `L1`
#. ยง1: `head :: tail`
#. ยง2: `my_append`
#. ยง3: `simp [my_append]`
#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "Recursive Case: ยง0 is ยง1.\n"
"Simplify using the definition of ยง2.\n"
"Type ยง3."
msgstr ""

#. ยง0: `h : P`
#. ยง1: `P`
#. ยง2: `exact h`
#: Game.Levels.LogicForEngineers.L02_Implication
msgid "Now you have ยง0 in your hypotheses, and you need to prove ยง1.\n"
"Use ยง2 to say 'this is exactly what we need'."
msgstr ""

#. ยง0: `cases`
#. ยง1: `h : P โจ Q`
#. ยง2: ```
#. cases h with
#. | inl hp => -- handle case where P is true
#. | inr hq => -- handle case where Q is true
#. ```
#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "Brilliant! You've mastered OR elimination.\n"
"\n"
"The ยง0 tactic is essential for handling hypotheses with multiple possibilities.\n"
"When you have ยง1, you must prove your goal in *both* cases:\n"
"- What if P is true?\n"
"- What if Q is true?\n"
"\n"
"**Pattern:**\n"
"ยง2"
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `cases h with | inl hp => ... | inr hq => ...`
#. ยง2: `hp`
#. ยง3: `hq`
#. ยง4: `P โจ Q โ Q โจ P`
#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "# Handling OR in Hypotheses\n"
"\n"
"When you *have* ยง0 as a hypothesis, you don't know which one is true.\n"
"You must handle both cases!\n"
"\n"
"Use ยง1 to split into:\n"
"- Case 1: assume P is true (called ยง2)\n"
"- Case 2: assume Q is true (called ยง3)\n"
"\n"
"This is like testing a circuit: if the OR gate outputs HIGH,\n"
"you check what happens if input A is HIGH, then what happens if input B is HIGH.\n"
"\n"
"Let's prove OR is commutative: ยง4"
msgstr ""

#: Game.Levels.TheDataCenter.L01_MapId
msgid "Prove that mapping the identity function returns the original list."
msgstr ""

#: Game
msgid "Logic for Engineers Game"
msgstr ""

#. ยง0: `constructor`
#. ยง1: `Q โง P`
#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "Now use ยง0 to prove ยง1 by proving both parts."
msgstr ""

#. ยง0: `constructor`
#. ยง1: `Q โ P`
#: Game.Levels.LogicForEngineers.L09_Iff
msgid "Now use ยง0 to prove both directions of ยง1."
msgstr ""

#. ยง0: `h : P โง (Q โจ R)`
#. ยง1: `P`
#. ยง2: `h.left`
#. ยง3: `Q โจ R`
#. ยง4: `h.right`
#. ยง5: `cases h.right`
#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "You have ยง0. Extract the common filter ยง1 with ยง2 and the join ยง3 with ยง4.\n"
"Use ยง5 to handle the two branches of the join."
msgstr ""

#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "Prove that appending two lists sums their lengths."
msgstr ""

#. ยง0: `True`
#. ยง1: `โข`
#. ยง2: `True`
#. ยง3: `trivial`
#: Game.Levels.LogicForEngineers.L01_TrueIsTrue
msgid "# Welcome to Logic for Engineers!\n"
"\n"
"In digital circuits, we work with signals that are either HIGH (1) or LOW (0).\n"
"In logic, we work with propositions that are either **True** or **False**.\n"
"\n"
"In Lean, ยง0 is the simplest proposition - it's always provable.\n"
"Think of it as a wire that's always connected to power.\n"
"\n"
"Your goal appears below the line ยง1. Right now, you need to prove ยง2.\n"
"\n"
"Use the ยง3 tactic to prove something that is... trivially true!"
msgstr ""

#. ยง0: `induction L`
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Induction is the standard tool for lists.\n"
"Type ยง0."
msgstr ""

#. ยง0: `ih`
#. ยง1: `(my_map f tail).length = tail.length`
#. ยง2: `(my_map f (head :: tail)).length = (head :: tail).length`
#. ยง3: `my_map`
#. ยง4: `simp [my_map]`
#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "Recursive Case: We have a head and a tail.\n"
"The Induction Hypothesis ยง0 says: ยง1.\n"
"We want to prove: ยง2.\n"
"\n"
"First, simplify the goal using the definition of ยง3. Type ยง4."
msgstr ""

#: Game.Levels.LogicForEngineers.L02_Implication
msgid "The Implication Gate"
msgstr ""

#. ยง0: `P โง R`
#. ยง1: `right`
#. ยง2: `constructor`
#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "In this case, we are in the right branch (R). Build the optimized right side ยง0.\n"
"Use ยง1 then ยง2."
msgstr ""

#: Game.Levels.TheDataCenter
msgid "The Data Center"
msgstr ""

#. ยง0: `intro h`
#. ยง1: `P โง Q`
#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "First, use ยง0 to assume ยง1 is true."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `h.left`
#. ยง2: `h.1`
#. ยง3: `P`
#. ยง4: `h.right`
#. ยง5: `h.2`
#. ยง6: `Q`
#. ยง7: `P โง Q โ Q โง P`
#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "# Extracting from AND\n"
"\n"
"If you know ยง0 is true, you can extract either piece:\n"
"- ยง1 or ยง2 gives you ยง3\n"
"- ยง4 or ยง5 gives you ยง6\n"
"\n"
"Think of it as probing the inputs of an AND gate that's outputting HIGH -\n"
"you know both inputs must be HIGH.\n"
"\n"
"This level proves AND is commutative: ยง7\n"
"(swapping the inputs doesn't change the logic)."
msgstr ""

#: Game
msgid "Learn propositional logic through digital circuit intuition. Master AND, OR, NOT gates as logical proofs!"
msgstr ""

#: Game
msgid "# Welcome to Logic for Engineers!\n"
"\n"
"Learn formal logic through the lens of digital circuits.\n"
"If you understand AND, OR, and NOT gates, you already know Boolean logic!\n"
"\n"
"**Worlds available:**\n"
"- **Logic for Engineers**: Master propositional logic using circuit intuition\n"
"- **The Data Center**: Verify data structures and prevent memory leaks\n"
"\n"
"Select a world to begin your journey into formal proofs!"
msgstr ""

#. ยง0: `my_reverse`
#. ยง1: ```lean
#. def my_reverse (L : List ฮฑ) : List ฮฑ :=
#.   match L with
#.   | [] => []
#.   | (h :: t) => my_append (my_reverse t) [h]
#. ```
#. ยง2: `(my_reverse L).length = L.length`
#. ยง3: `append_length`
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "# Ticket-1045: Backup Integrity Check\n"
"\n"
"**Status:** BLOCKED\n"
"**Priority:** P0 (Critical)\n"
"\n"
"**Description:**\n"
"Our backups are stored as reverse-ordered stacks on tape drives.\n"
"During restoration, we read the tape in reverse to reconstruct the database.\n"
"You must verify that the ยง0 operation preserves the total number of records.\n"
"Any discrepancy here means data loss.\n"
"\n"
"**The Code:**\n"
"ยง1\n"
"\n"
"**Acceptance Criteria:**\n"
"Prove that ยง2.\n"
"\n"
"**Tip:**\n"
"Consult the knowledge base: Ticket-1043 (ยง3)."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "De Morgan's Laws"
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `constructor`
#. ยง2: `โง`
#. ยง3: `\\and`
#. ยง4: `\\wedge`
#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "You've built an AND gate!\n"
"\n"
"When you see ยง0 as a goal, use ยง1 to split it into two goals.\n"
"Then prove each part using what you have.\n"
"\n"
"**Notation guide:**\n"
"- ยง2 is typed as ยง3 or ยง4\n"
"- It represents logical AND (conjunction)"
msgstr ""

#. ยง0: `hnq : ยฌQ`
#. ยง1: `hpq : P โง Q`
#. ยง2: `hpq.right`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "You have ยง0 and ยง1.\n"
"Extract Q from hpq with ยง2, then apply ยฌQ to it."
msgstr ""

#. ยง0: `my_map id (head :: tail)`
#. ยง1: `my_map`
#. ยง2: `simp [my_map]`
#: Game.Levels.TheDataCenter.L01_MapId
#: Game.Levels.TheDataCenter.L05_ReverseLength
msgid "Recursive Case: ยง0.\n"
"Simplify using the definition of ยง1.\n"
"Type ยง2."
msgstr ""

#. ยง0: `ยฌ(P โง Q) โ ยฌP โจ ยฌQ`
#. ยง1: `ยฌ(P โจ Q) โ ยฌP โง ยฌQ`
#. ยง2: `ยฌP โจ ยฌQ`
#. ยง3: `ยฌ(P โง Q)`
#. ยง4: `apply`
#. ยง5: `B`
#. ยง6: `h : A โ B`
#. ยง7: `apply h`
#. ยง8: `A`
#: Game.Levels.LogicForEngineers.L08_DeMorgan
msgid "# De Morgan's Laws: The Engineer's Best Friend\n"
"\n"
"**De Morgan's Laws** are fundamental in digital logic:\n"
"- ยง0 (NAND equals OR of NOTs)\n"
"- ยง1 (NOR equals AND of NOTs)\n"
"\n"
"Let's prove the easier direction of the first law:\n"
"If we know ยง2, then ยง3.\n"
"\n"
"Think about it: if at least one input to an AND gate is LOW,\n"
"the output must be LOW!\n"
"\n"
"**New tactic:** ยง4 lets you work backwards from the goal.\n"
"If you need to prove ยง5 and have ยง6, use ยง7 to change\n"
"the goal to proving ยง8."
msgstr ""

#: Game.Levels.LogicForEngineers.L05_OrIntro
msgid "If P is true, then P โจ Q is true."
msgstr ""

#. ยง0: `my_map`
#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "**Code Review Passed!**\n"
"\n"
"You have formally verified that ยง0 is memory-safe with respect to list length.\n"
"The C++ backend team breathes a sigh of relief.\n"
"\n"
"You've just used **Mathematical Induction** to verify software correctness.\n"
"This is the power of formal methods in engineering!"
msgstr ""

#. ยง0: `my_append`
#. ยง1: ```lean
#. def my_append (L1 L2 : List ฮฑ) : List ฮฑ :=
#.   match L1 with
#.   | [] => L2
#.   | (h :: t) => h :: my_append t L2
#. ```
#. ยง2: `length (my_append L1 L2) = length L1 + length L2`
#: Game.Levels.TheDataCenter.L03_AppendLength
msgid "# Ticket-1043: Merge Logic Verification\n"
"\n"
"**Status:** OPEN\n"
"**Priority:** P1\n"
"\n"
"**Description:**\n"
"We are implementing a ยง0 function to merge data shards.\n"
"Data Integrity checks require that the total record count matches the sum of the two shards.\n"
"If records are lost during the merge, we will fail our audit.\n"
"\n"
"**The Code:**\n"
"ยง1\n"
"\n"
"**Acceptance Criteria:**\n"
"Prove that ยง2."
msgstr ""

#. ยง0: `cases h with | inl hp => ... | inr hq => ...`
#. ยง1: `cases h`
#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "Now use ยง0 to handle both possibilities.\n"
"\n"
"Or simply use ยง1 and handle each case."
msgstr ""

#. ยง0: `trivial`
#. ยง1: `True`
#: Game.Levels.LogicForEngineers.L01_TrueIsTrue
msgid "Type ยง0 to prove that ยง1 holds."
msgstr ""

#: Game.Levels.LogicForEngineers.L10_Distributive
msgid "One direction of the distributive law."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `P โง Q`
#. ยง2: `constructor`
#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "# AND: Both Must Be True\n"
"\n"
"An **AND gate** outputs HIGH only when *both* inputs are HIGH.\n"
"\n"
"In logic, ยง0 (read 'P and Q') is true only when both P and Q are true.\n"
"\n"
"To prove ยง1, you need to prove both parts:\n"
"- Use ยง2 to split the goal into two subgoals\n"
"- Prove each part separately\n"
"\n"
"Think of it as connecting two wires to an AND gate - you need to verify both inputs."
msgstr ""

#: Game.Levels.LogicForEngineers.L02_Implication
msgid "If P is true, then P is true."
msgstr ""

#. ยง0: `hq : Q`
#: Game.Levels.LogicForEngineers.L03_AndIntro
msgid "Now prove the second part. You have ยง0 in your hypotheses."
msgstr ""

#: Game
msgid "Here you can put additional information about the game. It is accessible\n"
"from the starting through the drop-down menu.\n"
"\n"
"For example: Game version, Credits, Link to Github and Zulip, etc.\n"
"\n"
"Use **markdown**."
msgstr ""

#: Game.Levels.TheDataCenter
msgid "# โ๏ธ SEV-1: Data Consistency Check\n"
"\n"
"**Status:** INVESTIGATING\n"
"**Assignee:** Senior Engineer (You)\n"
"**Context:** The Core Infrastructure Team is migrating our user database to a functional architecture.\n"
"\n"
"**The Incident:**\n"
"Management is afraid the new recursive algorithms might cause data loss or buffer overflows during the migration. Unit tests are passing, but that's not good enough for the banking module.\n"
"\n"
"**Your Orders:**\n"
"1. Enter the Data Center.\n"
"2. Formally verify the list operations.\n"
"3. **Prove** that the data remains intact.\n"
"\n"
"> \"We don't need tests. We need proofs.\" - The CTO"
msgstr ""

#: Game.Levels.TheDataCenter.L02_SafeMapping
msgid "Prove that mapping a function over a list does not change its length."
msgstr ""

#: Game.Levels.TheDataCenter.L01_MapId
msgid "Ticket-1041: Pipeline Integrity"
msgstr ""

#: Game.Levels.LogicForEngineers.L01_TrueIsTrue
msgid "True is True"
msgstr ""

#. ยง0: `hp : P`
#. ยง1: `Q โจ P`
#. ยง2: `right`
#. ยง3: `exact hp`
#: Game.Levels.LogicForEngineers.L06_OrElim
msgid "In this case, P is true (you have ยง0). You need ยง1.\n"
"Since you have P, use ยง2 then ยง3."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `hp : P`
#. ยง2: `left`
#: Game.Levels.LogicForEngineers.L05_OrIntro
msgid "You need to prove ยง0. You have ยง1.\n"
"Use ยง2 to say 'I'll prove the left side (P)'."
msgstr ""

#: Game.Levels.LogicForEngineers.L04_AndElim
msgid "Reading AND Outputs"
msgstr ""
